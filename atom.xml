<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>秋水墨色染</title>
  
  
  <link href="https://shaoshaossm.github.io/atom.xml" rel="self"/>
  
  <link href="https://shaoshaossm.github.io/"/>
  <updated>2021-09-21T14:46:45.049Z</updated>
  <id>https://shaoshaossm.github.io/</id>
  
  <author>
    <name>shaoshaossm</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>hexo-matery问题解决</title>
    <link href="https://shaoshaossm.github.io/2021-09-21-hexo-matery-wen-ti-jie-jue.html"/>
    <id>https://shaoshaossm.github.io/2021-09-21-hexo-matery-wen-ti-jie-jue.html</id>
    <published>2021-09-21T14:34:32.000Z</published>
    <updated>2021-09-21T14:46:45.049Z</updated>
    
    <content type="html"><![CDATA[<p>问: hexo g -d 突然无缘无故提交不上去,但本地 hexo server 是可以正常显示的?</p><p>答: 删除public文件夹重新跑命令hexo c hexo g -d ,不行就跑两次,等待成功.(就是这么不靠谱O(∩_∩)O)</p><p>问: 代码块中花括号被转义,不能正常显示?</p><p>答: 删除代码高亮插件,升级hexo版本到5.0以上</p><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">删除插件:- npm uninstall hexo-prism-plugin 升级版本:- cnpm install -g npm-upgrade         # 升级系统中的插件- cnpm update                         # 更新 hexo 及所有插件- hexo -v                             # 确认 hexo 已经更新<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;问: hexo g -d 突然无缘无故提交不上去,但本地 hexo server 是可以正常显示的?&lt;/p&gt;
&lt;p&gt;答: 删除public文件夹重新跑命令hexo c hexo g -d ,不行就跑两次,等待成功.(就是这么不靠谱O(∩_∩)O)&lt;/p&gt;
&lt;p&gt;问: 代码块</summary>
      
    
    
    
    <category term="hexo" scheme="https://shaoshaossm.github.io/categories/hexo/"/>
    
    
    <category term="matery" scheme="https://shaoshaossm.github.io/tags/matery/"/>
    
  </entry>
  
  <entry>
    <title>git命令学习</title>
    <link href="https://shaoshaossm.github.io/2021-09-21-git-ming-ling-xue-xi.html"/>
    <id>https://shaoshaossm.github.io/2021-09-21-git-ming-ling-xue-xi.html</id>
    <published>2021-09-21T11:03:54.000Z</published>
    <updated>2021-09-21T13:24:55.724Z</updated>
    
    <content type="html"><![CDATA[<ul><li>若下载分支的话需要加 <font color="dd0000"> -b </font>  + 分支名称 + 下载地址</li></ul><pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">$ git clone -b backup git@github.com:shaoshaossm&#x2F;shaoshaossm.github.io.git<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;若下载分支的话需要加 &lt;font color=&quot;dd0000&quot;&gt; -b &lt;/font&gt;  + 分支名称 + 下载地址&lt;/li&gt;
&lt;/ul&gt;
&lt;pre class=&quot;line-numbers language-shell&quot; data-language=&quot;shell</summary>
      
    
    
    
    <category term="后端" scheme="https://shaoshaossm.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="git" scheme="https://shaoshaossm.github.io/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>java数据结构和算法</title>
    <link href="https://shaoshaossm.github.io/2021-09-21-java-shu-ju-jie-gou-he-suan-fa.html"/>
    <id>https://shaoshaossm.github.io/2021-09-21-java-shu-ju-jie-gou-he-suan-fa.html</id>
    <published>2021-09-21T07:23:37.000Z</published>
    <updated>2021-09-21T09:49:48.202Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-稀疏数组sparsearray"><a href="#1-稀疏数组sparsearray" class="headerlink" title="1.稀疏数组sparsearray"></a>1.稀疏数组sparsearray</h3><p>基本介绍:</p><p>当一个数组中大部分元素为０，或者为同一个值的数组时，可以使用稀疏数组来保存该数组。</p><p>稀疏数组的处理方法是:</p><ul><li><p>记录数组一共有几行几列，有多少个不同的值</p></li><li><p>把具有不同值的元素的行列及值记录在一个小规模的数组中，从而缩小程序的规模</p></li></ul><p><img src="https://img-blog.csdnimg.cn/9c934b2eebc04a1f9ebdd7737b017824.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="稀疏数组"></p><p>二维数组转稀疏数组的思路:</p><ul><li><p>遍历原始的二维数组,得到有效数据的个数 sum</p></li><li><p>根据sum就可以创建稀疏数组 sparseArr int [sum+1] [13]</p></li><li><p>将二维数组的有效数据存入到稀疏数组</p></li></ul><p>稀疏数组转二维数组思路:</p><ul><li>先读取稀疏数组的第一行,根据第一行的数据,创建原始的二维数组</li><li>再读取稀疏数组后几行的数据,并赋给原始的二维数组即可</li></ul><p>代码实现:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * @author shaoshao * @version 1.0 * @date 2021&#x2F;9&#x2F;14 18:30 *&#x2F;public class SparseArray &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;创建一个二位数组 11*11        &#x2F;&#x2F;0: 表示没有去棋子  1:表示黑子  2: 表示蓝子        int [][] chessArr1 &#x3D; new int[11][11];        chessArr1[1][2] &#x3D; 1;        chessArr1[0][2] &#x3D; 1;        chessArr1[2][3] &#x3D; 2;        &#x2F;&#x2F;输出原始的二维数组        for (int[] row : chessArr1) &#123;            for (int data : row) &#123;                System.out.printf(&quot;%d\t&quot;, data);            &#125;            System.out.println();        &#125;        &#x2F;&#x2F;二维数组 ------&gt;  稀疏数组        &#x2F;&#x2F;1.遍历原始的二维数组得到sum总数        int sum &#x3D; 0;        for (int i &#x3D; 0; i &lt;chessArr1.length ; i++) &#123;            for (int j &#x3D; 0; j &lt;chessArr1.length ; j++) &#123;                if (chessArr1[i][j] !&#x3D; 0) &#123;                    sum++;                &#125;            &#125;        &#125;        &#x2F;&#x2F;2.创建对应的稀疏数组        int[][] sparseArr2 &#x3D; new int[sum+1][3];        &#x2F;&#x2F;给稀疏数组赋值        sparseArr2[0][0] &#x3D; chessArr1.length;        sparseArr2[0][1] &#x3D; chessArr1.length;        sparseArr2[0][2] &#x3D; sum;        &#x2F;&#x2F;遍历二维数组 将非0的值存放到sparseArr中        &#x2F;&#x2F; 用于记录第几个非0数据        int  count &#x3D; 0;        for (int i &#x3D; 0; i &lt;chessArr1.length ; i++) &#123;            for (int j &#x3D; 0; j &lt;chessArr1.length ; j++) &#123;                if (chessArr1[i][j] !&#x3D; 0) &#123;                    count++;                    sparseArr2[count][0] &#x3D; i;                    sparseArr2[count][1] &#x3D; j;                    sparseArr2[count][2] &#x3D; chessArr1[i][j];                &#125;            &#125;        &#125;        System.out.println();        System.out.println(&quot;得到的稀疏数组为~~~~&quot;);        for (int i &#x3D; 0; i &lt;sparseArr2.length ; i++) &#123;            System.out.printf(&quot;%d\t%d\t%d\t\n&quot;,sparseArr2[i][0],sparseArr2[i][1],sparseArr2[i][2]);        &#125;        System.out.println();        &#x2F;**         * 稀疏数组 ----&gt;二维数组         *&#x2F;        &#x2F;&#x2F;1.先读取稀疏数组的第一行,根据第一行数据,创建原始的二维数组        int[][] chessArr2 &#x3D; new int[sparseArr2[0][0]][sparseArr2[0][1]];        &#x2F;&#x2F;2.再读取稀疏数组从第二行开始的数据,并赋值给二维数组即可        for (int i &#x3D; 1; i &lt;sparseArr2.length ; i++) &#123;            chessArr2[sparseArr2[i][0]][sparseArr2[i][1]] &#x3D; sparseArr2[i][2];        &#125;        System.out.println(&quot;恢复后的二维数组~~~&quot;);        for (int[] row : chessArr2) &#123;            for (int data : row) &#123;                System.out.printf(&quot;%d\t&quot;,data);            &#125;            System.out.println();        &#125;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-队列"><a href="#2-队列" class="headerlink" title="2.队列"></a>2.队列</h3><p>基本介绍:</p><ul><li>队列是一个有序列表，可以用<strong>数组</strong>或是<strong>链表</strong>来实现。</li><li>遵循<strong>先入先出</strong>的原则。即：先存入队列的数据，要先取出。后存入的要后取出</li><li>使用数组模拟队列示意图:</li></ul><p><img src="https://img-blog.csdnimg.cn/bd6a1f1d78b94fa4b34cdfc28ff8318b.png" alt="使用数组模拟队列示意图"></p><h4 id="2-1-数组模拟队列数据"><a href="#2-1-数组模拟队列数据" class="headerlink" title="2.1 数组模拟队列数据"></a>2.1 数组模拟队列数据</h4><p>数据存入队列思路分析:</p><ul><li>将尾指针往后移：rear+1 , 当front == rear 【空】</li><li>若尾指针 rear 小于队列的最大下标 maxSize-1，则将数据存入 rear所指的数组元素中，否则无法存入数据。 rear == maxSize - 1[队列满]</li></ul><p>代码实现:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;&#x2F;** * @author shaoshao * @version 1.0 * @date 2021&#x2F;9&#x2F;15 9:39 *&#x2F;public class ArrayQueueDemo &#123;    public static void main(String[] args) &#123;        System.out.println(&quot;测试数组模拟环形队列~~&quot;);        &#x2F;&#x2F;创建队列        ArrayQueue queue &#x3D; new ArrayQueue(3);        &#x2F;&#x2F;接受用户输入        char key &#x3D; &#39; &#39;;        Scanner scanner &#x3D; new Scanner(System.in);        boolean loop &#x3D; true;        while (loop) &#123;            System.out.println(&quot;s(show): 显示队列&quot;);            System.out.println(&quot;e(exit): 退出程序&quot;);            System.out.println(&quot;a(add): 添加程序到队列&quot;);            System.out.println(&quot;g(get): 从队列中获取数据&quot;);            System.out.println(&quot;h(head): 查看队列头数据&quot;);            key &#x3D; scanner.next().charAt(0);            switch (key) &#123;                case &#39;s&#39;:                    queue.showQueue();                    break;                case &#39;a&#39;:                    System.out.println(&quot;请输入一个数&quot;);                    int value &#x3D; scanner.nextInt();                    queue.addQueue(value);                    break;                case &#39;g&#39;:                    try &#123;                        int res &#x3D; queue.getQueue();                        System.out.printf(&quot;取出的数据是%d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;h&#39;:                    try &#123;                        int res &#x3D; queue.headQueue();                        System.out.printf(&quot;取出的数据是%d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;e&#39;:                    scanner.close();                    loop &#x3D; false;                    break;                default:                    break;            &#125;        &#125;        System.out.println(&quot;程序退出&quot;);    &#125;&#125;&#x2F;** * 使用数组模拟队列 - 编写一个ArrayQueue类 *&#x2F;class ArrayQueue &#123;    private int maxSize; &#x2F;&#x2F;数组的最大容量    private int front; &#x2F;&#x2F;队列头    private int rear; &#x2F;&#x2F;队列尾    private int[] arr; &#x2F;&#x2F;该数组用于存放数据,模拟队列    &#x2F;&#x2F;创建队列的构造器    public ArrayQueue(int arrMaxSize) &#123;        this.maxSize &#x3D; arrMaxSize;        arr &#x3D; new int[maxSize];        front &#x3D; -1;        rear &#x3D; -1;    &#125;    &#x2F;&#x2F;判断队列是否满    public boolean isFull() &#123;        return rear &#x3D;&#x3D; maxSize - 1;    &#125;    &#x2F;&#x2F;判断队列是否为空    public boolean isEmpty() &#123;        return rear &#x3D;&#x3D; front;    &#125;    &#x2F;&#x2F;添加数据到队列中    public void addQueue(int n) &#123;        &#x2F;&#x2F;判断队列是否已满        if (isFull()) &#123;            System.out.println(&quot;队列已满不能加入数据!&quot;);            return;        &#125;        &#x2F;&#x2F;rear++;  i++先赋值然后加1 ++i是先+1然后赋值        arr[++rear] &#x3D; n;    &#125;    &#x2F;&#x2F;获取队列中的数据,出队列    public int getQueue() &#123;        &#x2F;&#x2F;判断队列是否为空        if (isEmpty()) &#123;            throw new RuntimeException(&quot;队列为空,不能取数据!&quot;);        &#125;        return arr[++front];    &#125;    &#x2F;&#x2F;显示队列中的所有数据    public void showQueue() &#123;        if (isEmpty()) &#123;            System.out.println(&quot;队列为空,没有数据~~~&quot;);            return;        &#125;        for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i, arr[i]);        &#125;    &#125;    &#x2F;&#x2F;显示队列的头数据    public int headQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;队列为空,没有数据~~&quot;);        &#125;        return arr[front + 1];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="2-2-数组模拟环形队列"><a href="#2-2-数组模拟环形队列" class="headerlink" title="2.2 数组模拟环形队列"></a>2.2 数组模拟环形队列</h4><p>分析说明</p><ul><li>尾索引的下一个为头索引时表示队列满,即将队列容量空出一个作为约定,这个在做判断队列满的时候需要注意(rear+1)%maxSize == front [满]</li><li>rear  == front [空]</li><li>队列中的有效的数据个数:(rear+maxSize-front)%maxSize //rear =1 front =0</li><li>front指向队列的第一个元素,front 的初始值是0</li><li>rear指向队列的最后一个元素的后一个位置,因为希望空出一个空间作为约定(判断队列是否满) rear的初始值是0</li></ul><p>代码实现:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">import java.util.Scanner;&#x2F;** * @author shaoshao * @version 1.0 * @date 2021&#x2F;9&#x2F;15 22:22 *&#x2F;public class CircleArrayQueueDemo &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;创建队列        CircleArray queue &#x3D; new CircleArray(4);&#x2F;&#x2F;这里设置的4其队列的有效数据最大是3        &#x2F;&#x2F;接受用户输入        char key &#x3D; &#39; &#39;;        Scanner scanner &#x3D; new Scanner(System.in);        boolean loop &#x3D; true;        while (loop) &#123;            System.out.println(&quot;s(show): 显示队列&quot;);            System.out.println(&quot;e(exit): 退出程序&quot;);            System.out.println(&quot;a(add): 添加程序到队列&quot;);            System.out.println(&quot;g(get): 从队列中获取数据&quot;);            System.out.println(&quot;h(head): 查看队列头数据&quot;);            key &#x3D; scanner.next().charAt(0);            switch (key) &#123;                case &#39;s&#39;:                    queue.showQueue();                    break;                case &#39;a&#39;:                    System.out.println(&quot;请输入一个数&quot;);                    int value &#x3D; scanner.nextInt();                    queue.addQueue(value);                    break;                case &#39;g&#39;:                    try &#123;                        int res &#x3D; queue.getQueue();                        System.out.printf(&quot;取出的数据是%d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;h&#39;:                    try &#123;                        int res &#x3D; queue.headQueue();                        System.out.printf(&quot;取出的数据是%d\n&quot;, res);                    &#125; catch (Exception e) &#123;                        System.out.println(e.getMessage());                    &#125;                    break;                case &#39;e&#39;:                    scanner.close();                    loop &#x3D; false;                    break;                default:                    break;            &#125;        &#125;        System.out.println(&quot;程序退出&quot;);    &#125;&#125;class CircleArray &#123;    private int maxSize; &#x2F;&#x2F;数组的最大容量    private int front; &#x2F;&#x2F;front指向队列的第一个元素,front 的初始值是0;    private int rear; &#x2F;&#x2F;rear指向队列的最后一个元素的后一个位置,因为希望空出一个空间作为约定(判断队列是否满) rear的初始值是0;    private int[] arr; &#x2F;&#x2F;该数组用于存放数据,模拟队列    public CircleArray(int arrMaxSize) &#123;        maxSize &#x3D; arrMaxSize;        arr &#x3D; new int[maxSize];    &#125;    &#x2F;&#x2F;判断队列是否满    public boolean isFull() &#123;        return (rear + 1) % maxSize &#x3D;&#x3D; front;    &#125;    &#x2F;&#x2F;判断队列是否为空    public boolean isEmpty() &#123;        return rear &#x3D;&#x3D; front;    &#125;    &#x2F;&#x2F;添加数据到队列中    public void addQueue(int n) &#123;        &#x2F;&#x2F;判断队列是否已满        if (isFull()) &#123;            System.out.println(&quot;队列已满不能加入数据&quot;);            return;        &#125;        &#x2F;&#x2F;直接将数据加入        arr[rear] &#x3D; n;        &#x2F;&#x2F;将 rear 后移,这里必须考虑取模        rear &#x3D; (rear + 1) % maxSize;    &#125;    &#x2F;&#x2F;获取队列中的数据,出队列    public int getQueue() &#123;        &#x2F;&#x2F;判断队列是否为空        if (isEmpty()) &#123;            throw new RuntimeException(&quot;队列为空,不能取数据!&quot;);        &#125;        &#x2F;**         * 这里需分析出front是指向队列的第一个元素         * 1.先把front 对应的值保留到一个临时变量         * 2.将front 后移,考虑取模         * 3.将临时变量返回         *&#x2F;        int value &#x3D; arr[front];        front &#x3D; (front + 1) % maxSize;        return value;    &#125;    &#x2F;&#x2F;显示队列中的所有数据    public void showQueue() &#123;        if (isEmpty()) &#123;            System.out.println(&quot;队列为空,没有数据~~~&quot;);            return;        &#125;        for (int i &#x3D; front; i &lt; front+size(); i++) &#123;            System.out.printf(&quot;arr[%d]&#x3D;%d\n&quot;, i%maxSize, arr[i%maxSize]);        &#125;    &#125;    &#x2F;&#x2F;求出当前队列有效数据的个数    public int size() &#123;        return (rear+maxSize-front)%maxSize;    &#125;    &#x2F;&#x2F;显示队列的头数据    public int headQueue() &#123;        if (isEmpty()) &#123;            throw new RuntimeException(&quot;队列为空,没有数据~~&quot;);        &#125;        return arr[front];    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-链表"><a href="#3-链表" class="headerlink" title="3.链表"></a>3.链表</h3><p>链表是有序的列表:</p><ul><li>链表是以节点的方式来存储,是链式存储</li><li>每个节点包含 data 域， next 域：指向下一个节点  </li><li>链表的<strong>各个节点不一定是连续存储</strong>.  </li><li>链表分带头节点的链表和没有头节点的链表，根据实际的需求来确定</li></ul><h4 id="3-1单向链表"><a href="#3-1单向链表" class="headerlink" title="3.1单向链表"></a>3.1单向链表</h4><ul><li>添加英雄,直接添加到链表尾部<ul><li>先创建一个head节点,用来表示单链表的头</li><li>后面每添加一个节点,就直接加入到链表的尾部</li><li>通过一个辅助变量遍历,帮助遍历整个链表</li></ul></li><li>添加英雄,根据<strong>排名</strong>将英雄插入指定位置<ul><li>首先根据辅助节点找到新添加节点的位置</li><li>新的节点.next = temp.next</li><li>将temp.next = 新的节点</li></ul></li><li>修改节点功能<ul><li>先找到该节点,通过遍历</li><li>temp.name = newHeroNode.name; temp.nickname = newHeroNode.nickname</li></ul></li><li>删除节点<ul><li>先找到需要删除的这个节点的前一个节点temp</li><li>temp.next = temp.next.next</li><li>被删除的节点,将不会有其他引用指向,会被gc回收</li></ul></li></ul><p>代码实现:</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * @author shaoshao * @version 1.0 * @date 2021&#x2F;9&#x2F;16 11:59 * &lt;p&gt; * 单向链表创建并直接添加到链表的尾部实现&amp;&amp;考虑排名将英雄添加到指定位置 *&#x2F;public class SingleLinkListDemo &#123;    public static void main(String[] args) &#123;        HeroNode heroNode1 &#x3D; new HeroNode(1, &quot;易&quot;, &quot;无极剑圣&quot;);        HeroNode heroNode2 &#x3D; new HeroNode(2, &quot;艾希&quot;, &quot;寒冰射手&quot;);        HeroNode heroNode3 &#x3D; new HeroNode(3, &quot;瑞兹&quot;, &quot;流浪法师&quot;);        HeroNode heroNode4 &#x3D; new HeroNode(4, &quot;提莫&quot;, &quot;迅捷斥候&quot;);        &#x2F;&#x2F;创建单向链表        SingleLinkList singleLinkList &#x3D; new SingleLinkList();        &#x2F;*singleLinkList.add(heroNode1);        singleLinkList.add(heroNode2);        singleLinkList.add(heroNode4);        singleLinkList.add(heroNode3);*&#x2F;        singleLinkList.addByOrder(heroNode1);        singleLinkList.addByOrder(heroNode2);        singleLinkList.addByOrder(heroNode4);        singleLinkList.addByOrder(heroNode3);        singleLinkList.addByOrder(heroNode3);        singleLinkList.list();        &#x2F;&#x2F;测试修改节点的代码        singleLinkList.update(new HeroNode(2, &quot;ad希&quot;, &quot;寒冰&quot;));        System.out.println(&quot;修改后的链表情况&quot;);        singleLinkList.list();        &#x2F;&#x2F;测试删除节点的代码        singleLinkList.del(4);        singleLinkList.del(3);        singleLinkList.del(2);        singleLinkList.del(1);        System.out.println(&quot;删除后的链表情况&quot;);        singleLinkList.list();    &#125;&#125;&#x2F;&#x2F;定义SingleLinkList 管理我们的英雄class SingleLinkList &#123;    &#x2F;&#x2F;先初始化一个头节点,不存放数据    private HeroNode head &#x3D; new HeroNode(0, &quot;&quot;, &quot;&quot;);    &#x2F;**     * 添加节点到单向链表     * 思路:当不考虑编号顺序时     * 1.找到当前链表的最后节点     * 2.将最后这个节点的next 指向新的节点     *&#x2F;    public void add(HeroNode heroNode) &#123;        &#x2F;&#x2F;因为head节点不能动,所以需要一个辅助节点变量temp        HeroNode temp &#x3D; head;        &#x2F;&#x2F;遍历链表,找到最后        while (temp.next !&#x3D; null) &#123;            temp &#x3D; temp.next;        &#125;        &#x2F;&#x2F;当退出while循环时temp就指向了链表的最后        temp.next &#x3D; heroNode;    &#125;    &#x2F;**     * 第二种添加节点的方式 根据英雄排名插入到指定位置     * (如果有排名则添加失败,并给出提示)     * 1.首先找到添加的新的节点的位置,通过辅助变量通过遍历来搞定     * 2.新的节点.next &#x3D; temp.next     * 3.将temp.next&#x3D;新的节点     *&#x2F;    public void addByOrder(HeroNode heroNode) &#123;        &#x2F;&#x2F;再次使用辅助节点来帮助我们找到添加的位置        &#x2F;&#x2F;因为单链表,因为我们找到temp 是位于添加位置的前一个节点,否则插入不了(1,,,4 若插入2的话temp要找的是1)        HeroNode temp &#x3D; head;        boolean flag &#x3D; false; &#x2F;&#x2F;flag 标志用于判断添加的编号是否已经存在,默认未false        while (true) &#123;            if (temp.next &#x3D;&#x3D; null) &#123; &#x2F;&#x2F;说明已经遍历到最后一个节点 直接在最后插入即可                break;            &#125;            if (temp.next.no &gt; heroNode.no) &#123; &#x2F;&#x2F;位置找到,就在temp的后面插入 heroNode(2) 添加在temp和temp.next(4)之间                break;            &#125; else if (temp.next.no &#x3D;&#x3D; heroNode.no) &#123;                flag &#x3D; true; &#x2F;&#x2F;编号存在                break;            &#125;            temp &#x3D; temp.next; &#x2F;&#x2F;上面三个条件都不成立 后移 遍历当前链表        &#125;        &#x2F;&#x2F;判断flag 的值        if (flag) &#123;            System.out.printf(&quot;准备插入英雄的编号 %d 已经存在,不能添加\n&quot;, heroNode.no);        &#125; else &#123;            &#x2F;&#x2F;插入到temp后面            heroNode.next &#x3D; temp.next;            temp.next &#x3D; heroNode;        &#125;    &#125;    &#x2F;&#x2F;修改节点的信息,根据no编号来修改,即no编号不修改    public void update(HeroNode newHeroNode) &#123;        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;链表为空&quot;);            return;        &#125;        &#x2F;&#x2F;根据no编号,找到需要修改的节点 定义辅助变量        HeroNode temp &#x3D; head.next;        boolean flag &#x3D; false;        while (temp !&#x3D; null) &#123;            if (temp.no &#x3D;&#x3D; newHeroNode.no) &#123;                &#x2F;&#x2F;找到了                flag &#x3D; true;                break;            &#125;            temp &#x3D; temp.next;        &#125;        &#x2F;&#x2F;根据flag 判断是否找到需要修改的节点        if (flag) &#123;            temp.name &#x3D; newHeroNode.name;            temp.nickname &#x3D; newHeroNode.nickname;        &#125; else &#123;            System.out.printf(&quot;没有找到编号%d 的节点,不能修改\n&quot;, newHeroNode.no);        &#125;    &#125;    &#x2F;**     * 删除节点     * 1. head 不能动,需要一个temp辅助节点找到待删除节点前一个节点     * 2. 说明我们在比较时,是temp.next.no和需要删除节点的no比较     *&#x2F;    public void del(int no) &#123;        HeroNode temp &#x3D; head;        boolean flag &#x3D; false; &#x2F;&#x2F;标志是否找到删除节点        while (temp.next !&#x3D; null) &#123;            if (temp.next.no &#x3D;&#x3D; no) &#123;                &#x2F;&#x2F;找到待删除节点的前一个节点temp                flag &#x3D; true;                break;            &#125;            temp &#x3D; temp.next;        &#125;        if ((flag)) &#123;            temp.next &#x3D; temp.next.next;        &#125; else &#123;            System.out.printf(&quot;要删除的 %d 节点不存在\n&quot;,no);        &#125;    &#125;    &#x2F;&#x2F;显示链表[遍历]    public void list() &#123;        &#x2F;&#x2F;判断链表是否为空        if (head.next &#x3D;&#x3D; null) &#123;            System.out.println(&quot;链表为空,没有数据~~~&quot;);            return;        &#125;        &#x2F;&#x2F;头节点不能动再次使用辅助变量temp来遍历        HeroNode temp &#x3D; head.next;        &#x2F;&#x2F;判断是否到最后        while (temp !&#x3D; null) &#123;            &#x2F;&#x2F;输出节点信息            System.out.println(temp);            &#x2F;&#x2F;将temp后移            temp &#x3D; temp.next;        &#125;    &#125;&#125;&#x2F;&#x2F;定义HeroNode,每个HeroNode对象就是一个节点class HeroNode &#123;    public int no;    public String name;    public String nickname;    public HeroNode next; &#x2F;&#x2F;指向下一个节点    &#x2F;&#x2F;构造器    public HeroNode(int no, String name, String nickname) &#123;        this.no &#x3D; no;        this.name &#x3D; name;        this.nickname &#x3D; nickname;    &#125;    &#x2F;&#x2F;为了显示方法 重写toString    @Override    public String toString() &#123;        return &quot;HeroNode&#123;&quot; +                &quot;no&#x3D;&quot; + no +                &quot;, name&#x3D;&#39;&quot; + name + &#39;\&#39;&#39; +                &quot;, nickname&#x3D;&#39;&quot; + nickname + &#39;\&#39;&#39; +                &#39;&#125;&#39;;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-稀疏数组sparsearray&quot;&gt;&lt;a href=&quot;#1-稀疏数组sparsearray&quot; class=&quot;headerlink&quot; title=&quot;1.稀疏数组sparsearray&quot;&gt;&lt;/a&gt;1.稀疏数组sparsearray&lt;/h3&gt;&lt;p&gt;基本介绍:&lt;/p&gt;
</summary>
      
    
    
    
    <category term="数据结构和算法" scheme="https://shaoshaossm.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
    
    <category term="java数据结构和算法" scheme="https://shaoshaossm.github.io/tags/java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络笔记合集</title>
    <link href="https://shaoshaossm.github.io/2021-09-19-ji-suan-ji-wang-luo-bi-ji-he-ji.html"/>
    <id>https://shaoshaossm.github.io/2021-09-19-ji-suan-ji-wang-luo-bi-ji-he-ji.html</id>
    <published>2021-09-19T11:45:48.000Z</published>
    <updated>2021-09-20T02:43:27.365Z</updated>
    
    <content type="html"><![CDATA[<ul><li>互联网与互连网</li></ul><p><img src="https://img-blog.csdnimg.cn/237d123d62844512bed27ab014d3fdfd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="互联网与互连网"></p><h3 id="1-客户-服务器"><a href="#1-客户-服务器" class="headerlink" title="1.客户-服务器"></a>1.客户-服务器</h3><ul><li>客户-服务器方式</li></ul><p><img src="https://img-blog.csdnimg.cn/5982ee46b80d49c2b91d8c9efcd38ca8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="客户-服务器方式"></p><ul><li>客户软件的特点</li></ul><p><img src="https://img-blog.csdnimg.cn/0360492d63d94feba665f9e98ffc1626.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="客户软件的特点"></p><ul><li>服务器软件的特点</li></ul><p><img src="https://img-blog.csdnimg.cn/ef2f191aeeb74d7e878987222a152f00.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="服务器软件的特点"></p><ul><li>互联网核心部分<ul><li>电路交换 —-(电话机)</li><li>分组交换</li><li>报文交换</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/c476dd130d63473b87d17a5b678552cb.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="互联网核心部分"></p><p>交换的含义就是<font color="#225CFF">转接</font>,从通信资源的分配角度来看,”交换”就是按照某种方式<font color="#225CFF">动态的分配</font>传输线路的资源</p><ul><li>电路交换特点</li></ul><p><img src="https://img-blog.csdnimg.cn/ec635f19d2584fefb3c45552c47e8cfd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="电路交换特点"></p><p><font color="#225CFF">电路交换的用户始终占用端到端的通信资源</font></p><ul><li><p>分组交换的主要特点</p><ul><li>分组交换采用<font color="#225CFF">存储转发</font><font>技术</li><li>在发送端,先把较长的报文<font color="#225CFF">划分成较短的、固定长度的数据段.</font></li></ul></li><li><p>分组交换的主要步骤</p><ul><li>每一个数据前面添加上<font color="#225CFF">首部</font>构成<font color="#225CFF">分组</font></li><li>分组交换网,以<font color="#225CFF">分组</font>作为数据传输单元</li><li><font color="#225CFF">依次</font>把各分组发送到接收端</li><li>接收端收到分组后<font color="#225CFF">剥去</font>首部还原成报文</li><li>最后,在接收端把收到的数据<font color="#225CFF">恢复成原来的报文</font></li></ul></li><li><p>分组交换的传出单元</p></li></ul><p><img src="https://img-blog.csdnimg.cn/7ab2a5785d374c4e97c22f53c8ff23b2.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="分组交换的传输单元"></p><h3 id="2-路由器"><a href="#2-路由器" class="headerlink" title="2.路由器"></a>2.路由器</h3><p><img src="https://img-blog.csdnimg.cn/f6f8c554213e468488b4c09342132964.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="路由器"> </p><h5 id="2-1主机和路由器的作用不同"><a href="#2-1主机和路由器的作用不同" class="headerlink" title="2.1主机和路由器的作用不同"></a>2.1主机和路由器的作用不同</h5><ul><li>主机是<font color="#225CFF">为用户进行信息处理</font>的,并向网络发送分组,从网络接收分组</li><li>路由器对分组进行<font color="#225CFF">存储转发</font>,最后把分组交付目的的主机</li></ul><hr><ul><li>分组交换的优点</li></ul><p><img src="https://img-blog.csdnimg.cn/97801f2ca78c45b6afe9a83a99cc880c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="分组交换的优点"></p><ul><li>三种交换的比较</li></ul><p><img src="https://img-blog.csdnimg.cn/7d33acf0f8274b1cb0c12ca88d8566aa.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="三种交换的比较"></p><h3 id="3-计算机网络的类别"><a href="#3-计算机网络的类别" class="headerlink" title="3.计算机网络的类别"></a>3.计算机网络的类别</h3><h5 id="3-1-计算机网络的定义"><a href="#3-1-计算机网络的定义" class="headerlink" title="3.1 计算机网络的定义"></a>3.1 计算机网络的定义</h5><p>定义:<font color="#225CFF">计算机网络主要是由一些通用的、可编程的硬件互连而成的,而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来传送多种不同类型的数据,并能支持广泛的和日益增长的应用</font>&gt;</p><h5 id="3-2-计算机网络类别"><a href="#3-2-计算机网络类别" class="headerlink" title="3.2 计算机网络类别"></a>3.2 计算机网络类别</h5><ul><li>广域网 WAN</li><li>城域网 MAN</li><li>局域网 LAN</li><li>个人局域网 PAN</li></ul><h3 id="4-计算机网络性能"><a href="#4-计算机网络性能" class="headerlink" title="4.计算机网络性能"></a>4.计算机网络性能</h3><h5 id="4-1计算机网络的性能指标"><a href="#4-1计算机网络的性能指标" class="headerlink" title="4.1计算机网络的性能指标"></a>4.1计算机网络的性能指标</h5><ul><li>速率   (bit是计算机中数据量的单位,<font color="#225CFF">速率</font>是指<font color="#225CFF">数据的传送速率</font>)</li><li>带宽   (指信号具有的<font color="#225CFF">频带宽度</font>,单位<font color="#225CFF">赫</font>) (用来表示网络中某 通道传送数据的能力 “<font color="#225CFF">最高数据率</font>“.单位<font color="#225CFF">bit/s</font>)</li></ul><p><img src="https://img-blog.csdnimg.cn/9c29bb33bfde49c29c45a19188bafcd8.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="数据信号流随时间的变化"></p><ul><li><p>吞吐量   (网速测量. <font color="#225CFF">吞吐量受网络的带宽或网络的额定速率的限制</font>)</p></li><li><p>时延</p><ul><li>发送时延 (也称传输时延)</li></ul><p><img src="https://img-blog.csdnimg.cn/c2355be614e14ed0a7983b1a847f5427.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="发送时延"></p><ul><li>传播时延 </li></ul><p><img src="https://img-blog.csdnimg.cn/33ca892fc8b64215b37a508f60dc3279.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="传播时延"></p><ul><li>处理时延   </li><li>排队时延  (分组在路由器输入输出队列中<font color="#225CFF">排队等待处理</font>&gt;所经历的时延,取决于<font color="#225CFF">网络中当时的通信量</font>&gt;)</li></ul><p>数据在网络中经历的总时延就是发送时延、传播时延、处理时延、和排队时延<font color="#225CFF">之和</font></p><p><img src="https://img-blog.csdnimg.cn/96c75a611dd0418ab48643bb35d177c4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="容易产生的错误概念"></p></li><li><p>时延带宽积  (又称为以<font color="#225CFF">比特为单位的链路长度</font>) (时延带宽积 = 传播时延 * 带宽 )</p></li><li><p>往返时间RTT </p><ul><li><font color="#225CFF">发送方发送数据开始,到发送方收到来自接收方的确认,总共经历的时间</font></li><li>在互联网中,往返时间还包括<font color="#225CFF">各中间结点</font>的处理时延、排队时延以及转发数据时的发送时延</li></ul></li><li><p>利用率</p><ul><li>分为<font color="#225CFF">信道利用率</font>和<font color="#225CFF">网络利用率</font></li><li><font color="#225CFF">信道利用率</font>指出某信道有百分之几的时间是被利用的(有数据通过).</li><li><font color="#225CFF">网络利用率</font>则是全网络的信道利用率的加权平均值</li><li>信道利用率<font color="#225CFF">并非越高越好</font>.当某信道的利用率增大时,该信道引起的时延也迅速增加</li></ul><p><img src="https://img-blog.csdnimg.cn/77c042fe2784470fa78fcd55e9befb7e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="时延与网络利用率的关系"></p></li></ul><h3 id="5-计算机网络的体系结构"><a href="#5-计算机网络的体系结构" class="headerlink" title="5.计算机网络的体系结构"></a>5.计算机网络的体系结构</h3><h5 id="5-1-计算机网络体系结构的形成"><a href="#5-1-计算机网络体系结构的形成" class="headerlink" title="5.1 计算机网络体系结构的形成"></a>5.1 计算机网络体系结构的形成</h5><ul><li>网络协议三要素与两种形式</li></ul><p><img src="https://img-blog.csdnimg.cn/ccc7df37b1b142069204b0c4ab1725cf.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="网络协议的三个组成要素"></p><ul><li><p>计算机网络的体系结构:</p></li><li><p>计算机网络的体系结构(architecture)<font color="#dd0000">计算机网络的各层</font>及其<font color="#dd0000">协议</font>的集合</p><ul><li>体系结构就是这个计算机网络及其部件<font color="#225CFF">所应完成的功能的精确定义</font></li><li><font color="#225CFF">实现 (implementation) </font>是遵循这种体系结构的前提下用何种硬件或软件完成这些功能的问题。</li></ul></li><li><p><font color="#225CFF">体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。</font></p></li><li><p>具有五层协议的体系结构 :</p></li></ul><p><img src="https://img-blog.csdnimg.cn/d481a11c386b4d069713b500cd7023e4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="具有五层协议的体系结构"></p><ul><li>协议和服务</li></ul><p><img src="https://img-blog.csdnimg.cn/6c01072663e94e0ca0da01a46652112a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="协议和服务"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;互联网与互连网&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/237d123d62844512bed27ab014d3fdfd.png?x-oss-process=image/watermark,type</summary>
      
    
    
    
    <category term="计算机网络" scheme="https://shaoshaossm.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="基本概述" scheme="https://shaoshaossm.github.io/tags/%E5%9F%BA%E6%9C%AC%E6%A6%82%E8%BF%B0/"/>
    
  </entry>
  
  <entry>
    <title>命题逻辑的基本概念</title>
    <link href="https://shaoshaossm.github.io/2021-09-19-ming-ti-luo-ji-de-ji-ben-gai-nian.html"/>
    <id>https://shaoshaossm.github.io/2021-09-19-ming-ti-luo-ji-de-ji-ben-gai-nian.html</id>
    <published>2021-09-19T09:04:00.000Z</published>
    <updated>2021-09-19T11:02:30.702Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数理逻辑"><a href="#数理逻辑" class="headerlink" title=" 数理逻辑"></a><center> 数理逻辑</h3><h4 id="1-命题逻辑的基本概念"><a href="#1-命题逻辑的基本概念" class="headerlink" title="1. 命题逻辑的基本概念"></a>1. 命题逻辑的基本概念</h4><h5 id="1-1命题与联结词"><a href="#1-1命题与联结词" class="headerlink" title="1.1命题与联结词"></a>1.1命题与联结词</h5><ul><li><p>否定联结词  ﹁</p></li><li><p>合取联结词  ∧</p></li><li><p>析取联结词  ∨</p></li><li><p>蕴含联结词  →</p></li><li><p>等价联结词  ↔</p><center>联结词﹁,∧,∨,→,↔的定义</li></ul><table><thead><tr><th align="center">p  |  q</th><th align="center">﹁p</th><th align="center">p∧q</th><th align="center">p∨q</th><th align="center">p→q</th><th align="center">p↔q</th></tr></thead><tbody><tr><td align="center">0      0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">0      1</td><td align="center">1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">0</td></tr><tr><td align="center">1      0</td><td align="center">0</td><td align="center">0</td><td align="center">1</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1     1</td><td align="center">0</td><td align="center">1</td><td align="center">1</td><td align="center">1</td><td align="center">1</td></tr></tbody></table><h4 id="1-2-命题公式极其赋值"><a href="#1-2-命题公式极其赋值" class="headerlink" title="1.2 命题公式极其赋值"></a>1.2 命题公式极其赋值</h4><ul><li><p>若公式A是单个的命题变项,则称A为0层公式</p></li><li><p>若指定的一组值使A为1,则称为这组值为A的<font color="#dd0000">成真赋值</font> ;若使A为0,则称这组值为A的 <font color="#dd0000">成假赋值</font> </p></li><li><p>将命题公式A在所有赋值下取值情况列成表,称作A的<font color="#dd0000">真值表</font></p></li><li><p>设A未任一命题公式</p><ul><li><p>若A在它的各种赋值下取值均为真,则称A为<font color="#dd0000">重言式</font>或<font color="#dd0000">永真式</font></p></li><li><p>若A在它的各种赋值下取值均为真,则称A为<font color="#dd0000">矛盾式</font>或<font color="#dd0000">永假式</font></p></li><li><p>若A不是矛盾式,则称A为<font color="#dd0000">可满足式</font></p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数理逻辑&quot;&gt;&lt;a href=&quot;#数理逻辑&quot; class=&quot;headerlink&quot; title=&quot; 数理逻辑&quot;&gt;&lt;/a&gt;&lt;center&gt; 数理逻辑&lt;/h3&gt;&lt;h4 id=&quot;1-命题逻辑的基本概念&quot;&gt;&lt;a href=&quot;#1-命题逻辑的基本概念&quot; class=&quot;head</summary>
      
    
    
    
    <category term="离散数学" scheme="https://shaoshaossm.github.io/categories/%E7%A6%BB%E6%95%A3%E6%95%B0%E5%AD%A6/"/>
    
    
    <category term="数理逻辑" scheme="https://shaoshaossm.github.io/tags/%E6%95%B0%E7%90%86%E9%80%BB%E8%BE%91/"/>
    
  </entry>
  
  <entry>
    <title>原码,补码,反码理解</title>
    <link href="https://shaoshaossm.github.io/2021-09-19-yuan-ma-bu-ma-fan-ma-li-jie.html"/>
    <id>https://shaoshaossm.github.io/2021-09-19-yuan-ma-bu-ma-fan-ma-li-jie.html</id>
    <published>2021-09-19T07:18:44.000Z</published>
    <updated>2021-09-19T08:29:33.792Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-原码"><a href="#1-原码" class="headerlink" title="1.原码"></a>1.原码</h3><p>正数的符号位用0表示,负数的符号位用1表示,其余位为数值,这种表示方法称为<strong>原码</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">X 105 ----&gt; 1101001BX &#x3D; +105 ,[X]原 &#x3D; 0110 1001BX &#x3D; - 105 ,[X]原 &#x3D; 1110 1001B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="2-反码"><a href="#2-反码" class="headerlink" title="2.反码"></a>2.反码</h3><p>正数的反码与原码相同,最高位为符号位,用0表示,其余位为数值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">[+4]反 &#x3D; 0000 0100B[31]反 &#x3D; 0001 1111B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>负数的反码为它的正数按位取反,就是连同符号位一同取反</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">[-4]反 &#x3D; 1111 1011B[-31]反 &#x3D; 1110 0000B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>所以,8位二进制数表示的反码范围为-127~+127,当带符号数用反码表示时,最高位为符号数,当他为正数时,后7位为真正的值,当它为负数时,后7为要取反才能得到真正的值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">[X]反 &#x3D; 1001 0100B[X]真值 &#x3D; -[1101011] &#x3D; -107<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="3-补码"><a href="#3-补码" class="headerlink" title="3.补码"></a>3.补码</h3><p>正数的补码表示与原码相同,最高位为符号位,用0表示,其余位为真值,负数的补码最高位为1,数值部分由他的反码再加1形成</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">[+4]原 &#x3D; 0000 0100 &#x3D; [+4]反 &#x3D; [+4]补[-4]原 &#x3D; 1000 0100B[-4]反 &#x3D; 1111 1011B   (正数按位取反)[-4]补 &#x3D; 1111 1100B<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="补码–-gt-真数"><a href="#补码–-gt-真数" class="headerlink" title="补码–&gt;真数"></a>补码–&gt;真数</h3><p>当符号位用补码表示时,最高位是符号位,当符号位是0时,表示正数,后7位为其真正的数;当符号位是1时,表示负数,要将后7位最低位减1,求得反码,在按位取反,才能得到真正的数(<strong>真数</strong>)</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 已知[X]补 &#x3D; 10010100B,求X的反码和原码[X]反 &#x3D; [X]补-1 &#x3D; 1001 0100B-1 &#x3D; 1001 0011B[X]原 &#x3D; 1110 1100BX &#x3D; -110 1100B &#x3D; -(64+32+8+4)10 &#x3D; -108<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>引进补码后,可以将补码连同符号位一起看做一个数,各位的权都是2的i次方,但最高位为0时表示正数,为1时表示负数,其余为数值</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">[-128]补 &#x3D; 1000 0000B &#x3D; -128+0,最高位的权为2的7次方 &#x3D; 128,同理[-4]补 &#x3D; 1111 1100B &#x3D; -128+(64+32+16+8+4) &#x3D; -4[+4]补 &#x3D; 0000 0100B &#x3D; 4<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>所以, <font color=green>任何一个数用补码表示后,都可以看成”连同符号位的数”</font>.符号位也一起参加运算,一个数减去另一个数时,只要加上其补码即可.</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 求7-19&#x3D;? 可以用7+[-19]补来完成[7]补 &#x3D; 00000111B[+19]补 &#x3D; 00010011B[-19]补 &#x3D; 11101101B  0000 0111B [7]补+ 1110 1101B [-19]补--------------  11110100B &#x3D; F4H(和)和的补码 &#x3D; F4H &#x3D; 1111 0100B和的反码 &#x3D; F4H &#x3D; 1111 0011B和的原码 &#x3D; 1000 1100B 其真值未-12可见,7+(-19) &#x3D; -12.<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-原码&quot;&gt;&lt;a href=&quot;#1-原码&quot; class=&quot;headerlink&quot; title=&quot;1.原码&quot;&gt;&lt;/a&gt;1.原码&lt;/h3&gt;&lt;p&gt;正数的符号位用0表示,负数的符号位用1表示,其余位为数值,这种表示方法称为&lt;strong&gt;原码&lt;/strong&gt;&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="微机原理" scheme="https://shaoshaossm.github.io/categories/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="机器数" scheme="https://shaoshaossm.github.io/tags/%E6%9C%BA%E5%99%A8%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>进制转换总结</title>
    <link href="https://shaoshaossm.github.io/2021-09-19-jin-zhi-zhuan-huan-zong-jie.html"/>
    <id>https://shaoshaossm.github.io/2021-09-19-jin-zhi-zhuan-huan-zong-jie.html</id>
    <published>2021-09-19T06:09:11.000Z</published>
    <updated>2021-09-19T07:11:09.651Z</updated>
    
    <content type="html"><![CDATA[<h2 id="进制转换总结方法"><a href="#进制转换总结方法" class="headerlink" title="进制转换总结方法"></a>进制转换总结方法</h2><h3 id="1-十进制转换非十进制"><a href="#1-十进制转换非十进制" class="headerlink" title="1.  十进制转换非十进制"></a>1.  十进制转换非十进制</h3><p>总结:  十进制转换几进制就拿这个数除以几取余,知道商为0,然后倒叙写下来即可!<br>示例图:</p><p>   <img src="https://exp-picture.cdn.bcebos.com/3fe32442a07aa0107f5e7f8bbfbb19efa35f3ec1.jpg?x-bce-process=image/resize,m_lfit,w_500,limit_1/format,f_jpg/quality,q_80" alt="十进制转二进制"></p><h3 id="2-十进制小数部分转换非十进制"><a href="#2-十进制小数部分转换非十进制" class="headerlink" title="2. 十进制小数部分转换非十进制"></a>2. 十进制小数部分转换非十进制</h3><p>总结: 十进制转换几进制的小数部分就拿这个数的小数部分乘以几,得到的整数部分正序写到0.后面即可<br>方法：</p><p>1、乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，剩下的小数部分又乘以2，一直取到小数部分 。</p><p>2.为零为止。如果永远不能为零，就同十进制数的四舍五入一样，按照要求保留多少位小数时，就根据后面一位是0还是1，取舍，如果是零，舍掉，如果是1，向入一位。换句话说就是0舍1入。读数要从前面的整数读到后面的整数。</p><p>下面举例：<br>例1：将0.125换算为二进制<br>得出结果：将0.125换算为二进制（0.001）2 。</p><p>分析：</p><ul><li>第一步，将0.125乘以2，得0.25,则整数部分为0,小数部分为0.25。</li><li>第二步, 将小数部分0.25乘以2,得0.5,则整数部分为0,小数部分为0.5。</li><li>第三步, 将小数部分0.5乘以2,得1.0,则整数部分为1,小数部分为0.0。</li><li>第四步,读数,从第一位读起,读到最后一位,即为0.001。</li></ul><p><img src="https://iknow-pic.cdn.bcebos.com/e850352ac65c1038d8ca332ebc119313b17e89a2" alt="6.125转换成二进制"></p><h3 id="3-负整数转换成二进制"><a href="#3-负整数转换成二进制" class="headerlink" title="3.负整数转换成二进制"></a>3.负整数转换成二进制</h3><p>方法：先是将对应的正整数转换成二进制后，对二进制取反，然后对结果再加一。还以42为例，负整数就是-42，如图4所示为方法解释。最后即为：（-42）10=（11010110）2。<br><img src="https://iknow-pic.cdn.bcebos.com/11385343fbf2b2111d5e78a2c48065380dd78eee" alt="-42转换成二进制"></p><h3 id="4-正整数二进制转换为十进制"><a href="#4-正整数二进制转换为十进制" class="headerlink" title="4. 正整数二进制转换为十进制"></a>4. 正整数二进制转换为十进制</h3><p>方法: 首先将二进制数补齐位数，首位如果是0就代表是正整数，如果首位是1则代表是负整数。先看首位是0的正整数，补齐位数以后，将二进制中的位数分别将下边对应的值相乘，然后相加得到的就为十进制，比如1010转换为十进制。 </p><p><img src="https://iknow-pic.cdn.bcebos.com/fd039245d688d43f7eff6c1e731ed21b0ff43b8c?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_jpg" alt="1010转换成十进制"></p><h3 id="5-负整数二进制转换为十进制"><a href="#5-负整数二进制转换为十进制" class="headerlink" title="5 .负整数二进制转换为十进制"></a>5 .负整数二进制转换为十进制</h3><p>方法: 若二进制补足位数后首位为1时，就需要先取反再换算：例如，11101011，首位为1，那么就先取反吧：-00010100，然后算一下10100对应的十进制为20，所以对应的十进制为-20。</p><p><img src="https://iknow-pic.cdn.bcebos.com/838ba61ea8d3fd1f9cbe5fd63e4e251f94ca5fa3?x-bce-process=image/resize,m_lfit,w_600,h_800,limit_1/quality,q_85/format,f_jpg" alt="11101011"></p><h3 id="6-小知识点"><a href="#6-小知识点" class="headerlink" title="6. 小知识点"></a>6. 小知识点</h3><ol><li><p>表示二进制数时,后面必须加后缀B.</p></li><li><p>表示十六进制数时,后面必须加后缀H.</p></li><li><p>表示八进制数时,后面必须加后缀O或Q.</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;进制转换总结方法&quot;&gt;&lt;a href=&quot;#进制转换总结方法&quot; class=&quot;headerlink&quot; title=&quot;进制转换总结方法&quot;&gt;&lt;/a&gt;进制转换总结方法&lt;/h2&gt;&lt;h3 id=&quot;1-十进制转换非十进制&quot;&gt;&lt;a href=&quot;#1-十进制转换非十进制&quot; class</summary>
      
    
    
    
    <category term="微机原理" scheme="https://shaoshaossm.github.io/categories/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="进制转换" scheme="https://shaoshaossm.github.io/tags/%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>使用IDEA提交git代码</title>
    <link href="https://shaoshaossm.github.io/2021-09-19-shi-yong-idea-ti-jiao-git-dai-ma.html"/>
    <id>https://shaoshaossm.github.io/2021-09-19-shi-yong-idea-ti-jiao-git-dai-ma.html</id>
    <published>2021-09-18T16:13:33.000Z</published>
    <updated>2021-09-21T07:25:59.928Z</updated>
    
    <content type="html"><![CDATA[<h3 id="初次使用请多多见谅"><a href="#初次使用请多多见谅" class="headerlink" title="初次使用请多多见谅"></a>初次使用请多多见谅</h3><ol><li>创建一个空项目</li><li>点击如图所示</li></ol><pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/275115ac9cc843d0bdb001d8ec7f0fc4.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16)</code></pre><ol start="3"><li>下一步 点击如图所示</li></ol><pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/f6324e3f89684acb9f4216baf29aeeae.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16)</code></pre><ol start="4"><li>再点击如图所示<br><img src="https://img-blog.csdnimg.cn/e1718aea99f04c18b72bc675d042700f.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16" alt="在这里插入图片描述"></li><li>提示输入仓库地址 输入即可提交代码,如图所示</li></ol><pre><code>![在这里插入图片描述](https://img-blog.csdnimg.cn/1abec00e879f4c90a48272844a9acbf9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAd2VpeGluXzQ1MjAwNzM5,size_20,color_FFFFFF,t_70,g_se,x_16)</code></pre><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;初次使用请多多见谅&quot;&gt;&lt;a href=&quot;#初次使用请多多见谅&quot; class=&quot;headerlink&quot; title=&quot;初次使用请多多见谅&quot;&gt;&lt;/a&gt;初次使用请多多见谅&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;创建一个空项目&lt;/li&gt;
&lt;li&gt;点击如图所示&lt;/li&gt;
&lt;/ol&gt;
&lt;</summary>
      
    
    
    
    <category term="后端" scheme="https://shaoshaossm.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Git" scheme="https://shaoshaossm.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
