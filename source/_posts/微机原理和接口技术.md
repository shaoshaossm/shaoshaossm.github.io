---
title: 微机原理与接口技术
top: false
cover: false
toc: true
mathjax: true
date: 2021-09-19 14:09:11
password: 
summary: 进制转换、机器码、8086------------------------------------
tags: 基础理论
categories: 微机原理
---

### 1.进制转换总结方法

#### 1.1  十进制转换非十进制

总结:  十进制转换几进制就拿这个数除以几取余,知道商为0,然后倒叙写下来即可!
示例图:

   ![十进制转二进制](https://exp-picture.cdn.bcebos.com/3fe32442a07aa0107f5e7f8bbfbb19efa35f3ec1.jpg?x-bce-process=image%2Fresize%2Cm_lfit%2Cw_500%2Climit_1%2Fformat%2Cf_jpg%2Fquality%2Cq_80)

#### 1.2 十进制小数部分转换非十进制
总结: 十进制转换几进制的小数部分就拿这个数的小数部分乘以几,得到的整数部分正序写到0.后面即可
方法：

1、乘2取整法，即将小数部分乘以2，然后取整数部分，剩下的小数部分继续乘以2，然后取整数部分，剩下的小数部分又乘以2，一直取到小数部分 。

2.为零为止。如果永远不能为零，就同十进制数的四舍五入一样，按照要求保留多少位小数时，就根据后面一位是0还是1，取舍，如果是零，舍掉，如果是1，向入一位。换句话说就是0舍1入。读数要从前面的整数读到后面的整数。

下面举例：
例1：将0.125换算为二进制
得出结果：将0.125换算为二进制（0.001）2 。

分析：

- 第一步，将0.125乘以2，得0.25,则整数部分为0,小数部分为0.25。
- 第二步, 将小数部分0.25乘以2,得0.5,则整数部分为0,小数部分为0.5。
- 第三步, 将小数部分0.5乘以2,得1.0,则整数部分为1,小数部分为0.0。
- 第四步,读数,从第一位读起,读到最后一位,即为0.001。

![6.125转换成二进制](https://iknow-pic.cdn.bcebos.com/e850352ac65c1038d8ca332ebc119313b17e89a2)





#### 1.3 负整数转换成二进制

方法：先是将对应的正整数转换成二进制后，对二进制取反，然后对结果再加一。还以42为例，负整数就是-42，如图4所示为方法解释。最后即为：（-42）10=（11010110）2。 
![-42转换成二进制](https://iknow-pic.cdn.bcebos.com/11385343fbf2b2111d5e78a2c48065380dd78eee)

#### 1.4 正整数二进制转换为十进制 

方法: 首先将二进制数补齐位数，首位如果是0就代表是正整数，如果首位是1则代表是负整数。先看首位是0的正整数，补齐位数以后，将二进制中的位数分别将下边对应的值相乘，然后相加得到的就为十进制，比如1010转换为十进制。 

![1010转换成十进制](https://iknow-pic.cdn.bcebos.com/fd039245d688d43f7eff6c1e731ed21b0ff43b8c?x-bce-process%3Dimage%2Fresize%2Cm_lfit%2Cw_600%2Ch_800%2Climit_1%2Fquality%2Cq_85%2Fformat%2Cf_jpg)

#### 1.5 负整数二进制转换为十进制

方法: 若二进制补足位数后首位为1时，就需要先取反再换算：例如，11101011，首位为1，那么就先取反吧：-00010100，然后算一下10100对应的十进制为20，所以对应的十进制为-20。

![11101011](https://iknow-pic.cdn.bcebos.com/838ba61ea8d3fd1f9cbe5fd63e4e251f94ca5fa3?x-bce-process%3Dimage%2Fresize%2Cm_lfit%2Cw_600%2Ch_800%2Climit_1%2Fquality%2Cq_85%2Fformat%2Cf_jpg)

#### 1.6 小知识点

1. 表示二进制数时,后面必须加后缀B.
2. 表示十六进制数时,后面必须加后缀H.
3. 表示八进制数时,后面必须加后缀O或Q.

#### 1.7 二进制相减

```java
	101001B	  
-	011010B
--------------
    001111B   
 0-1 向前面遇到的第一个的1借位变成2-1并把途中的0都改为1,且1变为0
```

---

### 2.机器码


#### 2.1原码

正数的符号位用0表示,负数的符号位用1表示,其余位为数值,这种表示方法称为**原码**

```java
X 105 ----> 1101001B

X = +105 ,[X]原 = 0110 1001B

X = - 105 ,[X]原 = 1110 1001B
```

#### 2.2反码

正数的反码与原码相同,最高位为符号位,用0表示,其余位为数值

```java
[+4]反 = 0000 0100B

[31]反 = 0001 1111B
```

负数反码为它的正数按位取反,就是连同符号位一同取反

```java
[-4]反 = 1111 1011B
[-31]反 = 1110 0000B
```

所以,8位二进制数表示的反码范围为-127~+127,当带符号数用反码表示时,最高位为符号数,当他为正数时,后7位为真正的值,当它为负数时,后7为要取反才能得到真正的值

```java
[X]反 = 1001 0100B
[X]真值 = -[1101011] = -107
```

#### 2.3补码

正数的补码表示与原码相同,最高位为符号位,用0表示,其余位为真值,负数的补码最高位为1,数值部分由他的反码再加1形成

```java
[+4]原 = 0000 0100 = [+4]反 = [+4]补
[-4]原 = 1000 0100B
[-4]反 = 1111 1011B   (正数按位取反)
[-4]补 = 1111 1100B
```

### 补码-->真数

当符号位用补码表示时,最高位是符号位,当符号位是0时,表示正数,后7位为其真正的数;当符号位是1时,表示负数,要将后7位最低位减1,求得反码,在按位取反,才能得到真正的数(**真数**)

```java
// 已知[X]补 = 10010100B,求X的反码和原码
[X]反 = [X]补-1 = 1001 0100B-1 = 1001 0011B
[X]原 = 1110 1100B
X = -110 1100B = -(64+32+8+4)10 = -108
```

引进补码后,可以将补码连同符号位一起看做一个数,各位的权都是2的i次方,但最高位为0时表示正数,为1时表示负数,其余为数值

```java
[-128]补 = 1000 0000B = -128+0,最高位的权为2的7次方 = 128,同理
[-4]补 = 1111 1100B = -128+(64+32+16+8+4) = -4
[+4]补 = 0000 0100B = 4
```

所以, <font color=green>任何一个数用补码表示后,都可以看成"连同符号位的数"</font>.符号位也一起参加运算,一个数减去另一个数时,只要加上其补码即可.

```java
// 求7-19=? 可以用7+[-19]补来完成
[7]补 = 00000111B
[+19]补 = 00010011B
[-19]补 = 11101101B
  0000 0111B [7]补
+ 1110 1101B [-19]补
--------------
  11110100B = F4H(和)
和的补码 = F4H = 1111 0100B
和的反码 = F4H = 1111 0011B
和的原码 = 1000 1100B 其真值未-12
可见,7+(-19) = -12.
```

### 3.微处理器的结构和工作模式

- 8080/8088 CPU可直接寻址<font color=green>1MB</font>个内存单元,<font color=green>64kb</font>个I/O端口,他们的外部数据总线分别有<font color=green>16,8</font>根.
- CF : 进行算数加减法运算时,最高位向前一位<font color=green>产生进位或借位</font>时,CF=1,否为CD=0
- PF : 运算结果低八位有<font color=green>偶数</font>个1则CF=1,有<font color=green>奇数</font>个1则CF=0
- AF : 在8位加减运算中,<font color=green>若低4位向高4位有进位或借位</font>,AF=1,否则AF=0,=**这个结果只在BCD数运算时才有意义** (BCD数: 用4位2进制数表示10进制 eg: 0001＝1  0010＝2 )
- ZF : 若<font color=green>减法运算结果</font>为0,ZF=1否则ZF=0.ZF 标志常用来判断两个数是否相等,若相等,相减后ZF=1,若不等则ZF=0
- SF : 若<font color=green>运算结果(8位,不算进的那一位)最高位</font>为1,则SF=1,表示该数为负数,否则SF=0,表示该数为正数
- OF : 若运算结果超出机器所能表示的范围,运算结果是错误的<font color=green>(两个正(负)数相加为负(正)数</font>错误(同号相减肯定为0,异号相减肯定为1))就称为溢出OF=1,否则OF=0
- 8086CPU内部由<font color=green>执行单元EU</font>和<font color=green>总线接口单元BIU</font>组成。
  - 主要功能为:执行单元EU负责执行指令.它由算数逻辑单元、通用寄存器组、代码、对其译码后产生完成指令所需要的控制信息。
  - 总线接口单元BIU负责CPU与寄存器和I/O 接口之间的信息传递

1. 两个带符号数 10110100B 和 11000111B 相加,运算后各标志的值等于多少,哪些标志是有意义的?如果吧这两个数当成无符号数,相加后哪些标志位是有意义的?

```java
  10110100B
+ 11000111B
-------------
1 01111011B
CF=1,有进位
PF=1,结果有偶数个1
AF=0,无半进位,非BCD码运算,无意义
ZF=0,结果非0
SF=0,结果为正数
OF=1,溢出(两个负数相加,结果为正数)
(2) 两个无符号数(只有正数,没有负数):不考虑SF和OF标志
  10110100B
+ 11000111B
-------------
1 01111011B
CF=1,有进位
PF=1,结果有偶数个1
ZF=0,结果非0
AF、SF、OF无意义

```

2. 已知段地址:偏移地址分别为如下数值,他们的物理地址各是什么?

（1）1200：3500H    （2）FF00：0458H    （3）3A60：0100H

运算方法：

- 先将第一个寄存器的数值×16,即后面加个0. 
- 再将它第二个寄存器中的偏移量相加即可

```java
  12000H        ff000H      3A600H
+  3500H     +   0458H    +  0100h
-------------------------------------
  15500H       0FF458H      3A700H
```

3. 段基地址装入如下数值,则每段的起始地址和结束地址各是什么?

（1）1200H      （2）3F05H        （3）0FFEH

运算方法：16进制(0-F) F:15  逢16进1

- 起始地址: 段基地址×16,即后面加个0
- 结束地址: 段基地址×16+FFFFH

```java
(1) 12000H ~ 21FFFH     (2) 3F050H ~ 4F04FH     (3) 0FFE0H ~ 1FFDFH
    12000H                  3F050H                  0FFE0H
+    FFFFH               +   FFFFH               +   FFFFH
----------------------------------------------------------------------
    21FFFH                  4F04FH                  1FFDFH
```

4. 设SS:SP = 2000:0300H,则堆栈在内存中的物理地址范围是什么?执行两条push指令后,SS:SP=?再执行一条POP指令后,SS:SP=?

```java
也就是求物理地址: 20000H ~ 202ffH
入栈:SS:SP: 2000:02FCH
    0300H             
 -  0004H
 ------------
    02FCH
出栈:SS:SP: 2000:02FEH
    02FCH
 +  0002H
 ------------
    02FEH
```

5. 8086工作于最小模式时,执行存储器读总线周期,T1~T4周期中主要完成哪些工作?

- T1: M/*IO,地址出现20位的地址

- T2: AD15--AD0 地址撤销,成高阻,A19--A16传输状态信息

- T3: 采样READY信息,如为1则CPU读取数据,否则插入等待周期

- T4: 数据从数据总线上撤销

### 4.8086的寻址方式和指令系统

![寻址方式判断](https://img-blog.csdnimg.cn/0c1c7d9e10fa468e80946079b9472631.png)

![指令判断](https://img-blog.csdnimg.cn/2ad3be2d094a498aa01126bce95dc7ce.png)

1. 已知:DS=1000H,BX=0200H,SI=02H,内存 10200H ~ 10205H单元的内容分别为10H,2AH,3CH46H,59H,6BH.下列每条指令执行完后AX寄存器的内容各是什么?

```java
// 方法: (6): 0200+02+02=0204H  然后从内容 0-5 中数到下标第四个(也就是第五个数) 然后答案就是后面那个数加数到的那个数,即 6B59H
(1) MOV AX , 0200H     0200H      (2) MOV AX , [200H]       2A10H
(3) MOV AX , BX        0200H      (4) MOV AX , 3[BX]        5946H
(5) MOV AX , [BX+SI]   463CH      (6) MOV AX , 2[BX+SI]     6B59H
```

2. 设DS=1000H，ES=2000H，SS=3500H，SI=00A0H，DI=0024H，BX=0100H，BP=0200H，数据段中变量名为 VAL 的偏移地址值为 0030H，试说明下列源操作数字段的寻址方式是什么?物理地址值是多少?

```java
//方法: 有BX,SI 直接用DS=1000H×16=10000H,再加上后面对应的值即可
//      有ES 直接用ES=2000H×16=20000H,再加上后面对应的值即可
//      有BP 直接用SS=3500H×16=35000H,再加上后面对应的值即可
// 总结: BP 用 SS ES 用 ES 其余都用 DS
(1)MOV AX，[100H]      直接,10100H	    	    (2)MOV AX，VAL             直接，10030H
(3)MOV AX，[BX]        寄存器间接,10100H		 (4)MOV AX，ES:[BX]         寄存器间接，20100H
(5)MOV AX，[SI]        寄存器间接,100A0H        (6)MOV AX，[BX+10H]        寄存器相对，10110H
(7)MOV AX，[BP]        寄存器间接,35200H        (8)MOV AX，VAL[BP+SI]     相对基址变址，352D0H
(9)MOV AX，VAL[BX+DI]  相对基址变址,10154H      (10)MOV AX，[BP+DI]        基址变址，35224H
```

3. 已知 AX=2508H，BX=0F36H，CX=0004H，DX=1864H，求下列每条指令执行后的结果是什么?标志位 CF 等于什么?    **AX(2508H) = AH(25H)+AL(08H)**           

```java
(1) AND AH,CL		(2) OR BL,30H		 (3) NOT AX
(4) XOR CX,0FFFOH    (5) TEST DH,0FH      (6) CMP CX,00H
(7) SHR DX,CL        (8) SAR AL,1         (9) SHL BH,CL
(10) SAL AX,1        (11) RCL BX,1        (12) ROR DX,CL
-------------------------------------------------------------
(1) AH = 25H  CL = 04H        (2)     BL = 36H                  (3)   AX = 2508H
    100101B                           110110B             (取反) 00100101B 00001000B  	  
  * 000100B                   (∨)    110000B                    11011010B 11110111B
------------------               ------------------            ------------------      
    000100B = 04H                     110110B  = 36H                   DAF7H
04替换AH的25 : AX = 0408H         36替换BL的36 : BX = 0F36H      AX即原2508H的BCD数转2进制取反，为DAF7H
---------------------------------------------------------------------------------------
(4)  异或运算                  (5)     逻辑与运算                (6)    比较
    0000 0000 0000 0100B              00011000B                       0004H
  0 1111 1111 1111 0000B      (∧)    00001111B                  -     00H
-------------------------         -----------------            ------------------    
    1111 1111 1111 0100B              00001000B                       0004H
源操作数和目的操作数转换为BCD码       两操作数逻辑与运算结果二进制       将目的操作数减去源操作数，结果不返回到目的
的二进制数，并进行异或运算。          数有1，零标志位ZF取0,结果不返回。  操作数，仅将结果反映在标志位。
      CX=0FFF4H。                      DX=01864H                      CX=0004H
---------------------------------------------------------------------------------------    
 (7)  逻辑右移                  (8) AL = 08H                       (9) BH = 0FH CL = 04H
   最低位进入CF，最高位补0.           1000B 右移一位                     1111B 左移四位
   1864/2^4=0186H                    100B (04H)                       11110000B  (F0H)  
------------------               ------------------                ------------------    
    DX=0186H                    04H替换AL的08H即可 : AX = 2504H      F0替换BH的0F即可 BX : F036H
---------------------------------------------------------------------------------------               
 (10)  算数左移                 (11)  进位的循环左移                 (12) 循环右移
   AX=2508H                           BX=0F36H                        DX=1864H CL=04H=2^4=16
 *       2                          *       2                         DX=1864H/16=186H...4
  ------------------               ------------------               ------------------    
   1代表左移一位，即*2^1               1代表左移一位，即*2^1             

        AX=4A10H                      BX=1E6CH                        循环右移将余数放在最左边，4186H
```

- **中断指令**是指计算机在执行正常的程序时,由于某些事件的发生,需要暂时中止当前程序的运行,转到中断服务程序去为临时发生的事件服务,终端服务程序执行完毕后,又返回正常程序继续运行,这个过程称为中断
- **汇编语言**也称为符号语言,用助记符来代替二进制的机器指令操作码,是一系列指令功能的英文缩写
- **位**:二进制数的每一位是组成二进制信息的最小单位
- **字节**:8个二进制信息组成的一个单位称为1个字节
- **字**:16个二进制也就是两个字节
- **字长**:决定计算机内部一次能处理二进制代码的位数
- **ASCAII**:用7位代码来表示计算机中存储的字母数组字符
- 二进制代码以指令组的形式存储在计算机中称为**程序**
- **计算机基本组成**:运算器控制器存储器,输入设备输出设备
- 一台计算机所能识别和执行的全部指令称为该机器的**指令集**
- 用二进制形式表示的指令称为**机器码**
- 每个单元有一个绝对地址称为**物理地址** 范围 00000~fffffh
- 20位物理地址 = 段基地址*16+16位偏移地址
- 8086最基本的工作是对存储器或io端口进行读写操作
- Cpu完成一次访问存储器或io端口的时间称为总线周期,执行一条指令的时间称为**指令周期**
- 每条指令的长短不同,一个指令周期可以有一个或几个总线周期组成
- **指令方式**是指令中说明操作数所在地址的方法

